#!/usr/bin/env bash
#═══════════════════════════════════════════════════════════════════════════════
# watchdog - Detect stuck agents via tmux pane content heuristics
#
# Scans all agent tmux windows for patterns that indicate the agent is stuck:
#   - Permission prompts (waiting for user approval)
#   - Plan mode (waiting for plan approval)
#   - Interactive inputs (AskUserQuestion, EnterPlanMode)
#   - Repeated error output (infinite loops)
#   - Crash/exit states (Claude exited, process dead)
#
# Usage:
#   watchdog scan              Scan all agents, report findings
#   watchdog scan --fix        Scan and auto-recover stuck agents
#   watchdog check <window>    Check a specific agent window
#   watchdog help              Show this help
#
# Exit codes:
#   0 = stuck agents found (or fixed)
#   1 = all agents healthy
#═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

CMUX_PROJECT_ROOT="${CMUX_PROJECT_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
CMUX_SESSION="${CMUX_SESSION:-cmux}"

# How many lines of pane output to capture for analysis
CAPTURE_LINES=30

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m'
BOLD='\033[1m'

#───────────────────────────────────────────────────────────────────────────────
# Stuck pattern definitions
#
# Each pattern has:
#   - regex: what to look for in pane output
#   - label: human-readable description
#   - severity: critical (blocks all work), warning (degraded), info
#   - fix: recovery command to send (empty = manual intervention needed)
#───────────────────────────────────────────────────────────────────────────────

# Check a single pane's output for stuck patterns
# Returns: "status|label|fix_command" or empty string
check_pane_content() {
    local pane_output="$1"
    local window_name="$2"

    # Pattern 1: Permission prompt — Claude Code's actual permission UI
    # The real prompt shows "Allow <tool>?" with yes/no options, or "Do you want to allow"
    # Only match Claude Code's specific permission format (line starts with permission indicator)
    if echo "$pane_output" | grep -qE '^\s*(Allow|Deny|Skip)\s' 2>/dev/null; then
        echo "critical|Waiting for permission approval|"
        return 0
    fi

    # Pattern 2: Plan mode — Claude Code shows a specific plan approval prompt
    # Only match if we see the actual plan mode UI indicator, not just text mentioning "plan"
    if echo "$pane_output" | grep -qE '(Plan mode active|Approve plan\?|plan:.*approve)' 2>/dev/null; then
        echo "critical|Stuck in plan mode (waiting for approval)|"
        return 0
    fi

    # Pattern 3: Interactive question — Claude Code's question UI shows numbered options
    # Only match the actual question UI format, not mentions of questions in text
    if echo "$pane_output" | grep -qE '^\s*(❯|>)\s+(Option|Choice)\s' 2>/dev/null; then
        echo "critical|Waiting for user question response|"
        return 0
    fi

    # Pattern 4: Claude exited / process dead
    if echo "$pane_output" | grep -qE '(claude.*exited|Session ended|Connection closed|returned to shell|\$ $)' 2>/dev/null; then
        # Verify by checking if Claude process is running in this pane
        local pane_pid
        pane_pid=$(tmux display-message -t "${CMUX_SESSION}:${window_name}" -p '#{pane_pid}' 2>/dev/null || echo "")
        if [[ -n "$pane_pid" ]]; then
            # Check if claude is in the process tree
            if ! pgrep -P "$pane_pid" -f "claude" >/dev/null 2>&1; then
                echo "critical|Claude process not running (exited or crashed)|"
                return 0
            fi
        fi
    fi

    # Pattern 5: Error loop — same error message repeated multiple times
    # Look for repeated lines in the last N lines
    local repeated
    repeated=$(echo "$pane_output" | grep -v '^\s*$' | sort | uniq -c | sort -rn | head -1 | awk '{print $1}')
    if [[ -n "$repeated" ]] && ((repeated > 5)); then
        local repeated_line
        repeated_line=$(echo "$pane_output" | grep -v '^\s*$' | sort | uniq -c | sort -rn | head -1 | sed 's/^\s*[0-9]* //' | head -c 80)
        echo "warning|Possible error loop (line repeated ${repeated}x): ${repeated_line}|"
        return 0
    fi

    # Pattern 6: Git conflict / merge state
    if echo "$pane_output" | grep -qiE '(CONFLICT|merge conflict|fix conflicts|Merge branch)' 2>/dev/null; then
        echo "warning|Git merge conflict detected|"
        return 0
    fi

    # Pattern 7: Disk full / resource exhaustion
    if echo "$pane_output" | grep -qiE '(No space left|disk full|ENOMEM|out of memory|Cannot allocate)' 2>/dev/null; then
        echo "critical|Resource exhaustion (disk/memory)|"
        return 0
    fi

    # Pattern 8: Rate limited
    if echo "$pane_output" | grep -qiE '(rate.?limit|429|too many requests|throttl)' 2>/dev/null; then
        echo "warning|Rate limited — may resolve on its own|"
        return 0
    fi

    # No stuck patterns found
    return 1
}

#───────────────────────────────────────────────────────────────────────────────
# Check a single agent window
#───────────────────────────────────────────────────────────────────────────────

check_agent() {
    local window_name="$1"
    local auto_fix="${2:-false}"

    # Capture pane output
    local pane_output
    pane_output=$(tmux capture-pane -t "${CMUX_SESSION}:${window_name}" -p -S -${CAPTURE_LINES} 2>/dev/null || echo "")

    if [[ -z "$pane_output" ]]; then
        echo "critical|Cannot capture pane (window may not exist)|"
        return 0
    fi

    local result
    if result=$(check_pane_content "$pane_output" "$window_name"); then
        local severity label fix_cmd
        severity=$(echo "$result" | cut -d'|' -f1)
        label=$(echo "$result" | cut -d'|' -f2)
        fix_cmd=$(echo "$result" | cut -d'|' -f3)

        # Report finding
        case "$severity" in
            critical) printf "  ${RED}●${NC} ${BOLD}%-20s${NC} ${RED}%s${NC}\n" "$window_name" "$label" ;;
            warning)  printf "  ${YELLOW}●${NC} ${BOLD}%-20s${NC} ${YELLOW}%s${NC}\n" "$window_name" "$label" ;;
            info)     printf "  ${CYAN}●${NC} ${BOLD}%-20s${NC} ${DIM}%s${NC}\n" "$window_name" "$label" ;;
        esac

        # Auto-fix if enabled and fix command available
        if [[ "$auto_fix" == "true" ]] && [[ -n "$fix_cmd" ]]; then
            printf "    ${DIM}→ Applying fix: %s${NC}\n" "$fix_cmd"
            tmux send-keys -t "${CMUX_SESSION}:${window_name}" "$fix_cmd" Enter 2>/dev/null || true
        fi

        return 0  # found issue
    fi

    return 1  # healthy
}

#───────────────────────────────────────────────────────────────────────────────
# Scan all agent windows
#───────────────────────────────────────────────────────────────────────────────

cmd_scan() {
    local auto_fix=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fix) auto_fix=true; shift ;;
            *) shift ;;
        esac
    done

    local windows
    windows=$(tmux list-windows -t "$CMUX_SESSION" -F '#{window_name}' 2>/dev/null || true)

    if [[ -z "$windows" ]]; then
        echo "No tmux session found"
        exit 1
    fi

    local found_issues=false
    local total_checked=0
    local critical_count=0
    local warning_count=0

    printf "${BOLD}Agent Watchdog Scan${NC}\n\n"

    while IFS= read -r wname; do
        [[ -z "$wname" ]] && continue
        # Skip system windows: monitor is infrastructure, supervisor has its own
        # heartbeat monitoring in monitor.sh — scanning it causes false positives
        # because the supervisor's pane contains tool output with detection patterns.
        [[ "$wname" == "monitor" ]] && continue
        [[ "$wname" == "supervisor" ]] && continue

        ((total_checked++))

        if check_agent "$wname" "$auto_fix"; then
            found_issues=true
            # Count by severity from the output
            local result
            result=$(tmux capture-pane -t "${CMUX_SESSION}:${wname}" -p -S -${CAPTURE_LINES} 2>/dev/null || echo "")
            if result_line=$(check_pane_content "$result" "$wname" 2>/dev/null); then
                local sev
                sev=$(echo "$result_line" | cut -d'|' -f1)
                case "$sev" in
                    critical) ((critical_count++)) ;;
                    warning)  ((warning_count++)) ;;
                esac
            fi
        else
            printf "  ${GREEN}●${NC} ${BOLD}%-20s${NC} ${DIM}healthy${NC}\n" "$wname"
        fi
    done <<< "$windows"

    echo ""
    printf "${DIM}Checked ${total_checked} agent(s)${NC}"
    if [[ "$found_issues" == "true" ]]; then
        printf " — "
        ((critical_count > 0)) && printf "${RED}${critical_count} critical${NC} "
        ((warning_count > 0)) && printf "${YELLOW}${warning_count} warning${NC}"
        echo ""
        exit 0
    else
        printf " — ${GREEN}all healthy${NC}\n"
        exit 1
    fi
}

#───────────────────────────────────────────────────────────────────────────────
# Check a specific window
#───────────────────────────────────────────────────────────────────────────────

cmd_check() {
    local window_name="${1:-}"
    if [[ -z "$window_name" ]]; then
        echo "Usage: watchdog check <window-name>"
        exit 1
    fi

    printf "${BOLD}Checking: ${window_name}${NC}\n"
    if check_agent "$window_name" false; then
        exit 0
    else
        printf "  ${GREEN}●${NC} ${BOLD}%-20s${NC} ${DIM}healthy${NC}\n" "$window_name"
        exit 1
    fi
}

#───────────────────────────────────────────────────────────────────────────────
# Help
#───────────────────────────────────────────────────────────────────────────────

cmd_help() {
    cat << 'EOF'
watchdog - Detect stuck agents via tmux pane content heuristics

USAGE:
    watchdog scan              Scan all agents, report findings
    watchdog scan --fix        Scan and auto-recover (where possible)
    watchdog check <window>    Check a specific agent window
    watchdog help              Show this help

DETECTION PATTERNS:
    Permission prompts     Agent waiting for tool approval
    Plan mode              Agent waiting for plan approval
    User questions         Agent waiting for AskUserQuestion response
    Process exit           Claude process no longer running
    Error loops            Same output line repeated >5 times
    Git conflicts          Merge conflict state detected
    Resource exhaustion    Disk full, out of memory
    Rate limiting          API rate limits detected

EXIT CODES:
    0 = stuck agents found
    1 = all agents healthy
EOF
}

#───────────────────────────────────────────────────────────────────────────────
# Main dispatch
#───────────────────────────────────────────────────────────────────────────────

cmd="${1:-scan}"
shift 2>/dev/null || true

case "$cmd" in
    scan)    cmd_scan "$@" ;;
    check)   cmd_check "$@" ;;
    help|-h|--help) cmd_help ;;
    *)
        echo "Unknown command: $cmd (try 'watchdog help')"
        exit 1
        ;;
esac
