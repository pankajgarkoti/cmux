#!/usr/bin/env bash
#===============================================================================
# tasks - Hierarchical task management backed by SQLite
#
# Usage:
#   tasks add <title> [--project <id>] [--assign <agent>] [--parent <task-id>]
#                     [--desc <description>] [--resources <comma-separated-urls>]
#   tasks list [--project <id>] [--status <status>] [--assign <agent>] [--all]
#   tasks tree [--project <id>]
#   tasks show <id>
#   tasks update <id> <status>
#   tasks assign <id> <agent>
#   tasks done <id>
#   tasks delete <id>
#   tasks help
#
# Storage: .cmux/tasks.db (SQLite with WAL mode)
# Designed for agents to manage hierarchical work breakdown.
#===============================================================================

set -euo pipefail

CMUX_HOME="${CMUX_HOME:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
DB="${CMUX_HOME}/.cmux/tasks.db"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

die() { echo -e "${RED}error:${NC} $1" >&2; exit 1; }
ok() { echo -e "${GREEN}✓${NC} $1"; }
warn() { echo -e "${YELLOW}!${NC} $1"; }

SEP="$(printf '\x1f')"  # Unit separator (ASCII 31) — safe for field splitting

#-------------------------------------------------------------------------------
# Database
#-------------------------------------------------------------------------------

ensure_db() {
    mkdir -p "$(dirname "$DB")"
    if [[ ! -f "$DB" ]]; then
        sqlite3 "$DB" <<'SQL'
CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT DEFAULT '',
    project TEXT DEFAULT '',
    assigned_to TEXT DEFAULT '',
    status TEXT DEFAULT 'pending',
    parent_id TEXT DEFAULT '',
    resources TEXT DEFAULT '[]',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    completed_at TEXT DEFAULT ''
);
SQL
    fi
    sqlite3 "$DB" 'PRAGMA journal_mode=WAL;' > /dev/null 2>&1
}

gen_id() {
    local chars='abcdefghijklmnopqrstuvwxyz0123456789'
    local id='t_'
    for _ in $(seq 1 8); do
        id+="${chars:$((RANDOM % ${#chars})):1}"
    done
    echo "$id"
}

status_color() {
    # Pad raw text first, then wrap with color to preserve column alignment
    local padded
    padded=$(printf "%-11s" "$1")
    case "$1" in
        pending)     echo -e "${DIM}${padded}${NC}" ;;
        assigned)    echo -e "${YELLOW}${padded}${NC}" ;;
        in-progress) echo -e "${BLUE}${padded}${NC}" ;;
        done)        echo -e "${GREEN}${padded}${NC}" ;;
        blocked)     echo -e "${RED}${padded}${NC}" ;;
        *)           echo "$padded" ;;
    esac
}

validate_status() {
    case "$1" in
        pending|assigned|in-progress|done|blocked) ;;
        *) die "invalid status: $1 (valid: pending, assigned, in-progress, done, blocked)" ;;
    esac
}

#-------------------------------------------------------------------------------
# Commands
#-------------------------------------------------------------------------------

cmd_add() {
    local title="" project="" assign="" parent="" desc="" resources=""

    # First positional arg is the title
    if [[ $# -gt 0 && "${1:0:2}" != "--" ]]; then
        title="$1"
        shift
    fi

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project)  project="${2:-}"; shift 2 ;;
            --assign)   assign="${2:-}"; shift 2 ;;
            --parent)   parent="${2:-}"; shift 2 ;;
            --desc)     desc="${2:-}"; shift 2 ;;
            --resources) resources="${2:-}"; shift 2 ;;
            *) die "unknown flag: $1" ;;
        esac
    done

    [[ -z "$title" ]] && die "usage: tasks add <title> [--project <id>] [--assign <agent>] [--parent <task-id>] [--desc <description>] [--resources <urls>]"

    ensure_db

    # Validate parent exists if given
    if [[ -n "$parent" ]]; then
        local parent_exists
        parent_exists=$(sqlite3 "$DB" "SELECT COUNT(*) FROM tasks WHERE id='$parent';")
        [[ "$parent_exists" == "0" ]] && die "parent task not found: $parent"
    fi

    local id
    id=$(gen_id)
    local now
    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    # Build resources JSON array
    local res_json='[]'
    if [[ -n "$resources" ]]; then
        res_json=$(echo "$resources" | tr ',' '\n' | jq -R . | jq -sc .)
    fi

    local status="pending"
    if [[ -n "$assign" ]]; then
        status="assigned"
    fi

    sqlite3 "$DB" "INSERT INTO tasks (id, title, description, project, assigned_to, status, parent_id, resources, created_at, updated_at)
        VALUES ('$id', '$(echo "$title" | sed "s/'/''/g")', '$(echo "$desc" | sed "s/'/''/g")', '$project', '$assign', '$status', '$parent', '$(echo "$res_json" | sed "s/'/''/g")', '$now', '$now');"

    ok "Created ${id}: ${title}"
    if [[ -n "$parent" ]]; then
        echo -e "  ${DIM}Parent: ${parent}${NC}"
    fi
    if [[ -n "$assign" ]]; then
        echo -e "  ${DIM}Assigned: ${assign}${NC}"
    fi
}

cmd_list() {
    local project="" status="" assign="" show_all=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project) project="${2:-}"; shift 2 ;;
            --status)  status="${2:-}"; shift 2 ;;
            --assign)  assign="${2:-}"; shift 2 ;;
            --all)     show_all=1; shift ;;
            *) die "unknown flag: $1" ;;
        esac
    done

    ensure_db

    local where="1=1"
    if [[ "$show_all" == "0" && -z "$status" ]]; then
        where="$where AND status != 'done'"
    fi
    if [[ -n "$project" ]]; then
        where="$where AND project = '$project'"
    fi
    if [[ -n "$status" ]]; then
        validate_status "$status"
        where="$where AND status = '$status'"
    fi
    if [[ -n "$assign" ]]; then
        where="$where AND assigned_to = '$assign'"
    fi

    local rows
    rows=$(sqlite3 -separator "$SEP" "$DB" "SELECT id, status, project, assigned_to, title FROM tasks WHERE $where ORDER BY created_at;")

    if [[ -z "$rows" ]]; then
        echo -e "${DIM}No tasks found${NC}"
        return
    fi

    echo -e "${BOLD}Tasks:${NC}"
    echo ""
    printf "${DIM}%-12s  %-11s  %-12s  %-12s  %s${NC}\n" "ID" "STATUS" "PROJECT" "ASSIGNED" "TITLE"
    echo -e "${DIM}────────────  ───────────  ────────────  ────────────  ─────────────────────────${NC}"

    local count=0
    while IFS="$SEP" read -r id st proj assigned ttl; do
        printf "%-12s  %b  %-12s  %-12s  %s\n" \
            "$id" \
            "$(status_color "$st")" \
            "${proj:--}" \
            "${assigned:--}" \
            "$ttl"
        ((count++))
    done <<< "$rows"

    echo ""
    echo -e "${DIM}${count} task(s)${NC}"
}

cmd_tree() {
    local project=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project) project="${2:-}"; shift 2 ;;
            *) die "unknown flag: $1" ;;
        esac
    done

    ensure_db

    local where="1=1"
    if [[ -n "$project" ]]; then
        where="project = '$project'"
    fi

    # Get all tasks
    local all_tasks
    all_tasks=$(sqlite3 -separator "$SEP" "$DB" "SELECT id, status, parent_id, title FROM tasks WHERE $where ORDER BY created_at;")

    if [[ -z "$all_tasks" ]]; then
        echo -e "${DIM}No tasks found${NC}"
        return
    fi

    echo -e "${BOLD}Task Tree:${NC}"
    echo ""

    # Print root tasks (no parent) and their children recursively
    _print_tree_children "" "" "$all_tasks"
}

_print_tree_children() {
    local parent_id="$1"
    local prefix="$2"
    local all_tasks="$3"

    # Find children of this parent
    local children=()
    while IFS="$SEP" read -r id st pid ttl; do
        [[ -z "$id" ]] && continue
        if [[ "$pid" == "$parent_id" ]]; then
            children+=("${id}|${st}|${ttl}")
        fi
    done <<< "$all_tasks"

    local total=${#children[@]}
    [[ "$total" -eq 0 ]] && return
    local i=0
    for child in "${children[@]}"; do
        ((i++))
        local cid cst cttl
        cid=$(echo "$child" | cut -d'|' -f1)
        cst=$(echo "$child" | cut -d'|' -f2)
        cttl=$(echo "$child" | cut -d'|' -f3-)

        local connector="├── "
        local next_prefix="${prefix}│   "
        if [[ $i -eq $total ]]; then
            connector="└── "
            next_prefix="${prefix}    "
        fi

        printf "%s%s%-12s  %b  %s\n" \
            "$prefix" "$connector" "$cid" "$(status_color "$cst")" "$cttl"

        # Recurse into children
        _print_tree_children "$cid" "$next_prefix" "$all_tasks"
    done
}

cmd_show() {
    local id="${1:-}"
    [[ -z "$id" ]] && die "usage: tasks show <id>"

    ensure_db

    # Query individual fields to avoid multiline JSON breaking read
    _qf() { sqlite3 "$DB" "SELECT $1 FROM tasks WHERE id='$id';"; }

    local exists
    exists=$(_qf "COUNT(*)")
    [[ "$exists" == "0" ]] && die "task not found: $id"

    local ttl st desc proj assigned pid res created updated completed
    ttl=$(_qf "title")
    st=$(_qf "status")
    desc=$(_qf "description")
    proj=$(_qf "project")
    assigned=$(_qf "assigned_to")
    pid=$(_qf "parent_id")
    res=$(_qf "resources")
    created=$(_qf "created_at")
    updated=$(_qf "updated_at")
    completed=$(_qf "completed_at")

    echo -e "${BOLD}Task ${id}${NC}"
    echo -e "  Title:       ${ttl}"
    echo -e "  Status:      $(status_color "$st")"
    if [[ -n "$desc" ]]; then
        echo -e "  Description: ${desc}"
    fi
    if [[ -n "$proj" ]]; then
        echo -e "  Project:     ${proj}"
    fi
    if [[ -n "$assigned" ]]; then
        echo -e "  Assigned:    ${assigned}"
    fi
    if [[ -n "$pid" ]]; then
        echo -e "  Parent:      ${pid}"
    fi
    if [[ "$res" != "[]" && -n "$res" ]]; then
        echo -e "  Resources:"
        echo "$res" | jq -r '.[]' 2>/dev/null | while read -r url; do
            echo -e "    - ${url}"
        done
    fi
    echo -e "  Created:     ${created}"
    echo -e "  Updated:     ${updated}"
    if [[ -n "$completed" ]]; then
        echo -e "  Completed:   ${completed}"
    fi

    # Show children
    local children
    children=$(sqlite3 -separator "$SEP" "$DB" "SELECT id, status, title FROM tasks WHERE parent_id='$id' ORDER BY created_at;")
    if [[ -n "$children" ]]; then
        echo ""
        echo -e "  ${BOLD}Children:${NC}"
        while IFS="$SEP" read -r cid cst cttl; do
            printf "    %-12s  %b  %s\n" "$cid" "$(status_color "$cst")" "$cttl"
        done <<< "$children"
    fi
}

cmd_update() {
    local id="${1:-}"
    local new_status="${2:-}"

    [[ -z "$id" ]] && die "usage: tasks update <id> <status>"
    [[ -z "$new_status" ]] && die "usage: tasks update <id> <status>"

    validate_status "$new_status"
    ensure_db

    local exists
    exists=$(sqlite3 "$DB" "SELECT COUNT(*) FROM tasks WHERE id='$id';")
    [[ "$exists" == "0" ]] && die "task not found: $id"

    local now
    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    local completed_clause=""
    if [[ "$new_status" == "done" ]]; then
        completed_clause=", completed_at='$now'"

        # Warn about incomplete children
        local undone_children
        undone_children=$(sqlite3 "$DB" "SELECT COUNT(*) FROM tasks WHERE parent_id='$id' AND status != 'done';")
        if [[ "$undone_children" -gt 0 ]]; then
            warn "${undone_children} child task(s) are not done"
        fi
    fi

    sqlite3 "$DB" "UPDATE tasks SET status='$new_status', updated_at='$now'${completed_clause} WHERE id='$id';"

    local title
    title=$(sqlite3 "$DB" "SELECT title FROM tasks WHERE id='$id';")
    ok "Updated ${id}: ${title} → $(status_color "$new_status")"
}

cmd_assign() {
    local id="${1:-}"
    local agent="${2:-}"

    [[ -z "$id" ]] && die "usage: tasks assign <id> <agent>"
    [[ -z "$agent" ]] && die "usage: tasks assign <id> <agent>"

    ensure_db

    local exists
    exists=$(sqlite3 "$DB" "SELECT COUNT(*) FROM tasks WHERE id='$id';")
    [[ "$exists" == "0" ]] && die "task not found: $id"

    local now
    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    # If currently pending, auto-advance to assigned
    local current_status
    current_status=$(sqlite3 "$DB" "SELECT status FROM tasks WHERE id='$id';")
    local status_clause=""
    if [[ "$current_status" == "pending" ]]; then
        status_clause=", status='assigned'"
    fi

    sqlite3 "$DB" "UPDATE tasks SET assigned_to='$agent', updated_at='$now'${status_clause} WHERE id='$id';"

    local title
    title=$(sqlite3 "$DB" "SELECT title FROM tasks WHERE id='$id';")
    ok "Assigned ${id}: ${title} → ${agent}"
}

cmd_done() {
    local id="${1:-}"
    [[ -z "$id" ]] && die "usage: tasks done <id>"

    cmd_update "$id" "done"
}

cmd_delete() {
    local id="${1:-}"
    [[ -z "$id" ]] && die "usage: tasks delete <id>"

    ensure_db

    local exists
    exists=$(sqlite3 "$DB" "SELECT COUNT(*) FROM tasks WHERE id='$id';")
    [[ "$exists" == "0" ]] && die "task not found: $id"

    # Count children for reporting
    local child_count
    child_count=$(_count_descendants "$id")

    # Delete recursively
    _delete_recursive "$id"

    local msg="Deleted ${id}"
    if [[ "$child_count" -gt 0 ]]; then
        msg+=" and ${child_count} child task(s)"
    fi
    ok "$msg"
}

_count_descendants() {
    local parent_id="$1"
    local count=0
    local children
    children=$(sqlite3 "$DB" "SELECT id FROM tasks WHERE parent_id='$parent_id';")

    for child_id in $children; do
        ((count++))
        local sub
        sub=$(_count_descendants "$child_id")
        ((count += sub))
    done
    echo "$count"
}

_delete_recursive() {
    local parent_id="$1"
    local children
    children=$(sqlite3 "$DB" "SELECT id FROM tasks WHERE parent_id='$parent_id';")

    for child_id in $children; do
        _delete_recursive "$child_id"
    done

    sqlite3 "$DB" "DELETE FROM tasks WHERE id='$parent_id';"
}

cmd_help() {
    cat << 'EOF'
tasks - Hierarchical task management backed by SQLite

USAGE:
    tasks <command> [arguments]

COMMANDS:
    add <title> [flags]              Create a task
        --project <id>               Associate with a project
        --assign <agent>             Assign to an agent (auto-sets status to assigned)
        --parent <task-id>           Set parent task for hierarchy
        --desc <description>         Add a description
        --resources <url1,url2>      Attach resource URLs (comma-separated)

    list [flags]                     List tasks (default: non-done)
        --project <id>               Filter by project
        --status <status>            Filter by status
        --assign <agent>             Filter by assignee
        --all                        Include done tasks

    tree [--project <id>]            Hierarchical view with indentation

    show <id>                        Full details of a task

    update <id> <status>             Change status
                                     Valid: pending, assigned, in-progress, done, blocked

    assign <id> <agent>              Assign task to an agent

    done <id>                        Shortcut for update <id> done

    delete <id>                      Delete task and all children

    help                             Show this help

EXAMPLES:
    tasks add "Implement auth" --project cmux --desc "JWT-based authentication"
    tasks add "Write login endpoint" --parent t_a3f8k2m9 --assign worker-auth
    tasks list --status blocked
    tasks tree --project cmux
    tasks update t_a3f8k2m9 in-progress
    tasks done t_a3f8k2m9
    tasks delete t_a3f8k2m9

STORAGE:
    .cmux/tasks.db — SQLite database with WAL mode for concurrent access.

ENVIRONMENT:
    CMUX_HOME    Project root (default: git rev-parse --show-toplevel)
EOF
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        add)     cmd_add "$@" ;;
        list)    cmd_list "$@" ;;
        tree)    cmd_tree "$@" ;;
        show)    cmd_show "$@" ;;
        update)  cmd_update "$@" ;;
        assign)  cmd_assign "$@" ;;
        done)    cmd_done "$@" ;;
        delete)  cmd_delete "$@" ;;
        help|--help|-h) cmd_help ;;
        *)       die "unknown command: $cmd (try 'tasks help')" ;;
    esac
}

main "$@"
