#!/usr/bin/env bash
#═══════════════════════════════════════════════════════════════════════════════
# workers - Manage worker agents from the supervisor
#
# Usage:
#   workers spawn <name> <task> [--dir <path>] [--project <id>] [--worktree]
#   workers kill <name>            - Terminate a worker
#   workers list                   - List all workers
#   workers send <name> <message>  - Send message to a worker
#   workers status <name>          - Get worker terminal output
#═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

CMUX_SESSION="${CMUX_SESSION:-cmux}"
CMUX_PROJECT_ROOT="${CMUX_PROJECT_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
STARTUP_DELAY=8

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

#───────────────────────────────────────────────────────────────────────────────
# Helpers
#───────────────────────────────────────────────────────────────────────────────

die() { echo -e "${RED}error:${NC} $1" >&2; exit 1; }
info() { echo -e "${CYAN}▶${NC} $1"; }
ok() { echo -e "${GREEN}✓${NC} $1"; }
warn() { echo -e "${YELLOW}!${NC} $1"; }

window_exists() {
    tmux list-windows -t "$CMUX_SESSION" -F '#{window_name}' 2>/dev/null | grep -qx "$1"
}

is_supervisor() {
    [[ "$1" == "supervisor" ]] || [[ "$1" == supervisor-* ]] || [[ "$1" == sup-* ]]
}

generate_agent_id() {
    # Generate ag_ + 8 random alphanumeric chars
    # Check agent registry for collisions and regenerate if needed
    local registry_file="${CMUX_PROJECT_ROOT}/.cmux/agent_registry.json"
    local attempt=0
    local id

    while [[ $attempt -lt 100 ]]; do
        id="ag_$(head -c 32 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 8)"
        # Ensure we got 8 chars (base64 filtering can sometimes produce fewer)
        if [[ ${#id} -ne 11 ]]; then
            ((attempt++))
            continue
        fi
        # Check for collision in registry
        if [[ -f "$registry_file" ]] && grep -q "\"$id\"" "$registry_file" 2>/dev/null; then
            ((attempt++))
            continue
        fi
        echo "$id"
        return 0
    done

    die "failed to generate unique agent ID after 100 attempts"
}

#───────────────────────────────────────────────────────────────────────────────
# Commands
#───────────────────────────────────────────────────────────────────────────────

cmd_spawn() {
    local name=""
    local task=""
    local worker_dir=""
    local project_id=""
    local use_worktree=false

    # Parse arguments: workers spawn <name> <task> [--dir <path>] [--project <id>] [--worktree]
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dir)
                [[ -z "${2:-}" ]] && die "--dir requires a path argument"
                worker_dir="$2"
                shift 2
                ;;
            --project)
                [[ -z "${2:-}" ]] && die "--project requires an ID argument"
                project_id="$2"
                shift 2
                ;;
            --worktree)
                use_worktree=true
                shift
                ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                elif [[ -z "$task" ]]; then
                    task="$1"
                else
                    die "unexpected argument: $1"
                fi
                shift
                ;;
        esac
    done

    [[ -z "$name" ]] && die "usage: workers spawn <name> <task> [--dir <path>] [--project <id>]"
    [[ -z "$task" ]] && die "usage: workers spawn <name> <task> [--dir <path>] [--project <id>]"

    # Validate --dir path exists
    if [[ -n "$worker_dir" ]]; then
        [[ -d "$worker_dir" ]] || die "directory does not exist: $worker_dir"
        # Resolve to absolute path
        worker_dir="$(cd "$worker_dir" && pwd)"
    fi

    # Default working directory is CMUX project root
    local cd_target="${worker_dir:-$CMUX_PROJECT_ROOT}"

    # Sanitize name
    name=$(echo "$name" | tr ' ' '-' | tr -cd 'a-zA-Z0-9-_')

    if window_exists "$name"; then
        die "worker '$name' already exists"
    fi

    # Set up git worktree if requested
    local worktree_path=""
    local worktree_branch=""
    if [[ "$use_worktree" == true ]]; then
        # Determine the source repo for the worktree.
        # If --dir was provided, use that as the source repo to branch from.
        # Otherwise, use the CWD's git root — this is critical for project
        # supervisors who cd into their project directory. Without this,
        # the worktree would branch from the inherited CMUX_PROJECT_ROOT
        # (the CMUX repo) instead of the project repo.
        local worktree_repo
        if [[ -n "$worker_dir" ]]; then
            worktree_repo="$worker_dir"
        else
            worktree_repo="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
        fi

        # Inherit project_id early for worktree path calculation
        local wt_project="${project_id:-${CMUX_PROJECT_ID:-cmux}}"
        worktree_branch="feat/${name}"
        worktree_path="${HOME}/.cmux/worktrees/${wt_project}/${name}"

        # NOTE: The worktree branches from HEAD of the source repo.
        # For the branching model to work correctly, the supervisor MUST checkout
        # their integration branch (e.g. feat/<batch-name>) BEFORE spawning workers.
        # Workers then branch from the integration branch, not from main.

        if [[ -d "$worktree_path" ]]; then
            info "Reusing existing worktree at $worktree_path"
        else
            info "Creating git worktree at $worktree_path on branch $worktree_branch"
            mkdir -p "$(dirname "$worktree_path")"
            # Create worktree with a new branch from HEAD
            # If the branch already exists (leftover from previous run), reuse it
            if git -C "$worktree_repo" branch --list "$worktree_branch" | grep -q "$worktree_branch"; then
                git -C "$worktree_repo" worktree add "$worktree_path" "$worktree_branch"
            else
                git -C "$worktree_repo" worktree add -b "$worktree_branch" "$worktree_path" HEAD
            fi
            ok "Worktree created (from $(basename "$worktree_repo"))"
        fi

        # Override working directory to the worktree
        cd_target="$worktree_path"
    fi

    # Generate unique agent ID
    local agent_id
    agent_id=$(generate_agent_id)
    info "Creating worker: $name (${agent_id})"

    # Create tmux window
    tmux new-window -t "${CMUX_SESSION}:" -n "$name"

    # Lock window name
    tmux set-option -t "${CMUX_SESSION}:${name}" allow-rename off 2>/dev/null || true

    # Inherit project_id from environment if not explicitly set via --project
    if [[ -z "$project_id" ]] && [[ -n "${CMUX_PROJECT_ID:-}" ]]; then
        project_id="$CMUX_PROJECT_ID"
    fi

    # Register in agent_registry.json so the API returns correct agent_id, role, project_id
    local reg_file="${CMUX_PROJECT_ROOT}/.cmux/agent_registry.json"
    if [[ ! -f "$reg_file" ]]; then
        echo '{}' > "$reg_file"
    fi
    local reg_tmp
    reg_tmp=$(mktemp)
    local now
    now="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    local reg_project="${project_id:-cmux}"
    local jq_filter='.[$key] = {
           "registered_at": $now,
           "type": "worker",
           "created_by": "tools/workers",
           "created_at": $now,
           "agent_id": $aid,
           "display_name": $key,
           "role": "worker",
           "project_id": $pid
       }'
    local jq_args=(--arg key "$name" --arg aid "$agent_id" --arg pid "$reg_project" --arg now "$now")

    # Add worktree fields if applicable
    if [[ -n "$worktree_path" ]]; then
        jq_filter='.[$key] = {
           "registered_at": $now,
           "type": "worker",
           "created_by": "tools/workers",
           "created_at": $now,
           "agent_id": $aid,
           "display_name": $key,
           "role": "worker",
           "project_id": $pid,
           "worktree_path": $wpath,
           "worktree_branch": $wbranch
       }'
        jq_args+=(--arg wpath "$worktree_path" --arg wbranch "$worktree_branch")
    fi

    jq "${jq_args[@]}" "$jq_filter" "$reg_file" > "$reg_tmp" && mv "$reg_tmp" "$reg_file"

    # Build environment variable exports
    local supervisor_name="${CMUX_AGENT_NAME:-supervisor}"
    local env_vars="CMUX_AGENT=true CMUX_AGENT_ID=${agent_id} CMUX_AGENT_NAME=${name} CMUX_SESSION=${CMUX_SESSION} CMUX_HOME=${CMUX_PROJECT_ROOT} CMUX_PORT=${CMUX_PORT:-8000} CMUX_SUPERVISOR=${supervisor_name} CLAUDE_CODE_ENABLE_PROMPT_SUGGESTION=false"
    if [[ -n "$project_id" ]]; then
        env_vars="${env_vars} CMUX_PROJECT_ID=${project_id}"
    fi

    # Build the command — prepend CMUX tools to PATH when working outside project root
    local spawn_cmd="export ${env_vars}"
    if [[ -n "$worker_dir" ]] || [[ -n "$worktree_path" ]]; then
        spawn_cmd="${spawn_cmd} && export PATH=${CMUX_PROJECT_ROOT}/tools:\$PATH"
    fi
    spawn_cmd="${spawn_cmd} && cd ${cd_target} && claude --dangerously-skip-permissions"

    # Start Claude with environment variables (two-step pattern for reliability)
    info "Starting Claude agent..."
    tmux send-keys -t "${CMUX_SESSION}:${name}" -l "$spawn_cmd"
    tmux send-keys -t "${CMUX_SESSION}:${name}" Enter

    # Wait for Claude to initialize
    info "Waiting ${STARTUP_DELAY}s for Claude to initialize..."
    sleep "$STARTUP_DELAY"

    # Disable vim mode if enabled (for reliable message delivery)
    if tmux capture-pane -t "${CMUX_SESSION}:${name}" -p | grep -qE "\-\- (INSERT|NORMAL|VISUAL) \-\-"; then
        tmux send-keys -t "${CMUX_SESSION}:${name}" -l "/vim"
        tmux send-keys -t "${CMUX_SESSION}:${name}" Enter
        sleep 1
    fi

    # Write worker context to temp file to avoid multiline paste issues
    # (Multiline tmux send-keys causes "[Pasted text]" that gets stuck in buffer)
    local context_dir="${CMUX_PROJECT_ROOT}/.cmux/worker-contexts"
    mkdir -p "$context_dir"
    local context_file="${context_dir}/${name}-context.md"

    cat > "$context_file" << EOF
You are a worker agent named '${name}' in the CMUX multi-agent system.

HIERARCHY: User → Supervisor Prime → Project Supervisors → Workers (you).
Your direct supervisor is ${supervisor_name}. Report to them via mailbox. Do NOT
communicate with the user directly — only your supervisor chain does that.

IMPORTANT: You are NOT chatting with a human user. You are an autonomous agent that:
- Receives tasks from your supervisor (${supervisor_name})
- Communicates with other agents via the /mailbox skill
- Journals your work via the /journal skill (do this frequently!)
- Should respond to messages that appear in your terminal
- Reports completion via: ./tools/mailbox done "summary"
- Reports blockers via: ./tools/mailbox blocked "issue"

When you see a message like '[cmux:${supervisor_name}] Do X', that's your supervisor assigning you work.

JOURNAL AS YOU WORK - use ./tools/journal log "what you did" after completing tasks,
making decisions, or learning something important. This is the system's long-term memory.

[SYS] TAG: If you respond to a heartbeat nudge, compaction recovery, or any system event
where you have no actionable work, prefix your response with [SYS]. Example: [SYS] Task complete. Idle.
This renders as a compact notification in the dashboard instead of cluttering chat.

Read docs/WORKER_ROLE.md for full worker guidelines.

YOUR TASK:
${task}
EOF

    # Add worktree info to context file if applicable
    if [[ -n "$worktree_path" ]]; then
        cat >> "$context_file" << WTEOF

WORKTREE:
You are on branch ${worktree_branch}, branched from the supervisor's integration branch.
Commit your work here. Do not switch branches. Do not merge into main.
Your supervisor will merge your branch back into the integration branch when you report [DONE].
WTEOF
    fi

    # Send single-line instruction telling Claude to read the context file
    # This avoids multiline paste issues entirely
    # Use absolute path so workers in external dirs can find the context file
    info "Sending task to worker..."
    local instruction="[cmux:${supervisor_name}] Read ${CMUX_PROJECT_ROOT}/.cmux/worker-contexts/${name}-context.md for your identity and task assignment. You are a worker agent managed by a supervisor, not a human user. Begin working on the task described there."
    tmux send-keys -t "${CMUX_SESSION}:${name}" -l "$instruction"
    sleep 0.1
    tmux send-keys -t "${CMUX_SESSION}:${name}" Enter

    ok "Worker '$name' spawned and task assigned"
    echo ""
    echo "Agent ID: $agent_id"
    echo "Task: $task"
    [[ -n "$worker_dir" ]] && echo "Directory: $cd_target"
    [[ -n "$worktree_path" ]] && echo "Worktree: $worktree_path"
    [[ -n "$worktree_branch" ]] && echo "Branch: $worktree_branch"
    [[ -n "$project_id" ]] && echo "Project: $project_id"
    echo "Window: ${CMUX_SESSION}:${name}"
}

cmd_kill() {
    local name="${1:-}"

    [[ -z "$name" ]] && die "usage: workers kill <name>"

    if is_supervisor "$name"; then
        die "cannot kill supervisor agents"
    fi

    if ! window_exists "$name"; then
        die "worker '$name' not found"
    fi

    info "Terminating worker: $name"

    # Archive the worker's conversation before killing
    info "Archiving conversation..."
    if curl -sX POST "http://localhost:8000/api/agents/${name}/archive" > /dev/null 2>&1; then
        ok "Conversation archived"
    else
        warn "Failed to archive conversation (server may be down)"
    fi

    # Send Ctrl+C first to gracefully stop Claude
    tmux send-keys -t "${CMUX_SESSION}:${name}" C-c
    sleep 1

    # Kill the window
    tmux kill-window -t "${CMUX_SESSION}:${name}"

    ok "Worker '$name' terminated"

    # Check for worktree and print preservation note
    local reg_file="${CMUX_PROJECT_ROOT}/.cmux/agent_registry.json"
    if [[ -f "$reg_file" ]]; then
        local wt_path wt_branch
        wt_path=$(jq -r --arg key "$name" '.[$key].worktree_path // empty' "$reg_file" 2>/dev/null)
        wt_branch=$(jq -r --arg key "$name" '.[$key].worktree_branch // empty' "$reg_file" 2>/dev/null)
        if [[ -n "$wt_path" ]]; then
            echo ""
            warn "Worktree preserved at ${wt_path} on branch ${wt_branch}."
            echo "  Use 'git worktree remove ${wt_path}' to clean up after merging."
        fi
    fi
}

cmd_list() {
    local windows
    windows=$(tmux list-windows -t "$CMUX_SESSION" -F '#{window_name}' 2>/dev/null || true)

    if [[ -z "$windows" ]]; then
        warn "No tmux session found"
        return 1
    fi

    echo "Workers in session '$CMUX_SESSION':"
    echo ""

    local count=0
    while IFS= read -r window; do
        # Skip system windows
        [[ "$window" == "monitor" ]] && continue

        if [[ "$window" == sup-* ]]; then
            echo -e "  ${CYAN}●${NC} $window (project-supervisor)"
        elif is_supervisor "$window"; then
            echo -e "  ${CYAN}●${NC} $window (supervisor)"
        else
            echo -e "  ${GREEN}●${NC} $window"
            ((count++))
        fi
    done <<< "$windows"

    echo ""
    echo "Total workers: $count"
}

cmd_send() {
    local name="${1:-}"
    local message="${2:-}"

    [[ -z "$name" ]] && die "usage: workers send <name> <message>"
    [[ -z "$message" ]] && die "usage: workers send <name> <message>"

    if ! window_exists "$name"; then
        die "worker '$name' not found"
    fi

    info "Sending message to: $name"

    # Store message in DB so it appears in dashboard chat
    local from_agent="${CMUX_AGENT_NAME:-supervisor}"
    curl -sf -X POST "http://localhost:${CMUX_PORT:-8000}/api/messages/internal" \
        -H "Content-Type: application/json" \
        -d "{\"from_agent\": $(printf '%s' "$from_agent" | jq -Rs .), \"to_agent\": $(printf '%s' "$name" | jq -Rs .), \"content\": $(printf '%s' "$message" | jq -Rs .), \"type\": \"task\"}" \
        >/dev/null 2>&1 || true

    # Send message using literal flag then Enter
    # Small delay between text and Enter ensures Claude Code receives both
    # (matches lib/tmux.sh delay pattern used by router)
    tmux send-keys -t "${CMUX_SESSION}:${name}" -l "$message"
    sleep 0.1
    tmux send-keys -t "${CMUX_SESSION}:${name}" Enter

    ok "Message sent to '$name'"
}

cmd_status() {
    local name="${1:-}"
    local lines="${2:-30}"

    [[ -z "$name" ]] && die "usage: workers status <name> [lines]"

    if ! window_exists "$name"; then
        die "worker '$name' not found"
    fi

    echo "=== Terminal output for '$name' (last $lines lines) ==="
    echo ""
    tmux capture-pane -t "${CMUX_SESSION}:${name}" -p -S "-${lines}"
}

cmd_help() {
    cat << 'EOF'
workers - Manage worker agents

USAGE:
    workers <command> [arguments]

COMMANDS:
    spawn <name> <task> [options]   Create a new worker and assign a task
    kill <name>                     Terminate a worker (not supervisors)
    list                            List all workers in the session
    send <name> <message>           Send a message to a worker
    status <name> [lines]           Show recent terminal output (default: 30 lines)
    help                            Show this help message

SPAWN OPTIONS:
    --dir <path>       Set worker's working directory (default: CMUX project root)
                       The path must exist. When set, CMUX tools are added to PATH.
    --project <id>     Associate worker with a project (sets CMUX_PROJECT_ID env var)
    --worktree         Create a git worktree for branch-isolated work.
                       Creates ~/.cmux/worktrees/<project>/<name> on branch feat/<name>.
                       When combined with --dir, uses --dir as the source repo.
                       Worktrees are preserved on kill.

EXAMPLES:
    workers spawn auth-worker "Implement JWT authentication in src/auth/"
    workers spawn api-worker "Fix the auth bug" --dir /path/to/my-api --project my-api
    workers spawn feature-x "Add feature X" --worktree
    workers send auth-worker "Also add refresh token support"
    workers status auth-worker 50
    workers kill auth-worker
    workers list

ENVIRONMENT:
    CMUX_SESSION       tmux session name (default: cmux)
    CMUX_PROJECT_ROOT  project root directory (default: git root or pwd)
    CMUX_HOME          CMUX installation root (set automatically for workers)
    CMUX_PORT          server port (default: 8000)
    CMUX_PROJECT_ID    project association (set via --project flag)
    CMUX_SUPERVISOR    direct supervisor name (set automatically from spawner)
EOF
}

#───────────────────────────────────────────────────────────────────────────────
# Main
#───────────────────────────────────────────────────────────────────────────────

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        spawn)  cmd_spawn "$@" ;;
        kill)   cmd_kill "$@" ;;
        list)   cmd_list "$@" ;;
        send)   cmd_send "$@" ;;
        status) cmd_status "$@" ;;
        help|--help|-h) cmd_help ;;
        *)      die "unknown command: $cmd (try 'workers help')" ;;
    esac
}

main "$@"
